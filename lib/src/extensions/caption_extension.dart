import 'dart:convert';

import 'package:xml/xml.dart' as xml;

import '../exceptions/exceptions.dart';
import '../models/models.dart';
import '../youtube_explode_base.dart';
import 'helpers_extension.dart';

/// Caption extension for [YoutubeExplode]
extension CaptionExtension on YoutubeExplode {
  /// Gets all available closed caption track infos for given video.
  /// Returns an empty list of no caption is available.
  Future<List<ClosedCaptionTrackInfo>> getVideoClosedCaptionTrackInfos(
      String videoId) async {
    if (!YoutubeExplode.validateVideoId(videoId)) {
      throw ArgumentError.value(videoId, 'videoId', 'Invalid video id');
    }

    var videoInfoDic = await getVideoInfoDictionary(videoId);

    var playerResponseJson = json.decode(videoInfoDic['player_response']);

    var playAbility = playerResponseJson['playabilityStatus'];

    if (playAbility['status'].toLowerCase() == 'error') {
      throw VideoUnavailableException(videoId);
    }

    var captionTracks = playerResponseJson['captions'];

    if (captionTracks == null) {
      return const [];
    }

    var trackInfos = <ClosedCaptionTrackInfo>[];
    for (var trackJson in captionTracks['playerCaptionsTracklistRenderer']
        ['captionTracks']) {
      var url = Uri.parse(trackJson['baseUrl']);

      var query = Map<String, String>.from(url.queryParameters);
      query['format'] = '3';

      url = url.replace(queryParameters: query);

      var languageCode = trackJson['languageCode'];
      var languageName = trackJson['name']['simpleText'];
      var language = Language(languageCode, languageName);

      var isAutoGenerated = trackJson['vssId'].toLowerCase().startsWith('a.');

      trackInfos.add(ClosedCaptionTrackInfo(url, language,
          isAutoGenerated: isAutoGenerated));
    }
    return trackInfos;
  }

  Future<xml.XmlDocument> _getClosedCaptionTrackXml(Uri url) async {
    var raw = (await client.get(url)).body;

    return xml.parse(raw);
  }

  /// Gets the closed caption track associated with given metadata.
  Future<ClosedCaptionTrack> getClosedCaptionTrack(
      ClosedCaptionTrackInfo info) async {
    var trackXml = await _getClosedCaptionTrackXml(info.url);

    var captions = <ClosedCaption>[];
    for (var captionXml in trackXml.findAllElements('p')) {
      var text = captionXml.text;
      if (text.isNullOrWhiteSpace) {
        continue;
      }

      var offset =
          Duration(milliseconds: int.parse(captionXml.getAttribute('t')));
      var duration = Duration(
          milliseconds: int.parse(captionXml.getAttribute('d') ?? '-1'));

      captions.add(ClosedCaption(text, offset, duration));
    }

    return ClosedCaptionTrack(info, captions);
  }
}

/// Extension for List of [ClosedCaptions]
extension CaptionListExtension on List<ClosedCaption> {
  /// Get the [ClosedCaption] displayed at [time].
  /// [time] can be an [int] (time in seconds) or a [Duration].
  ClosedCaption getByTime(dynamic time) {
    Duration duration;
    if (time is int) {
      duration = Duration(seconds: time);
    } else {
      duration = time;
    }

    return firstWhere((e) => e.start <= duration && duration <= e.end);
  }
}
